# 关于 Cloudflare 上 HTML 解析的一段历史：第一部分

恰逢 Cloudflare Workers 发布流式 HTML 重写功能之际，我们开源了用于支持 Workers HTMLRewriter API 所使用的 Rust HTML 重写器（LOL HTML）。我们也认为现在是时候回顾一下 Cloudflare 上 HTML 重写的历史了。

第一篇博文会解释流式 HTML 重写器的基本原理以及我们对它的一些特别要求。事情大概要从 8 年前的那一批专用解析器讲起，这些工具被开发出来是专门用来实现某些特定功能的，比如重写电子邮件地址或者精简 HTML 体积。直到 2016 年，使用 HTML5 标准中所定义的状态机，我们可以构建一个简单的标准兼容的 HTML 可插拔重写器，用来替代当时存在的那批解析器。目前这个重写器的源码已经公开，可以到这里查看：https://github.com/cloudflare/lazyhtml

第二篇博文会描述重写器的第二次迭代。随着边缘计算平台 Cloudflare Workers 的发布，我们逐渐意识到开发者需要同样的但具有 Javascript API 的 HTML 重写功能。这篇博文讲述了带有基于 CSS 选择器的 API 的低延迟流式 HTML 重写器背后的设计思路。我们已经开源了这个 Rust 库，因为它同样可以被用来当作一个可单独使用的 HTML 重写/解析库。

## 什么是流式 HTML 重写器

一个流式 HTML 重写器，能够将一个 HTML 字符串或者字节流的输入，解析成令牌或任何采用其它结构的中间表示（IR）——比如说抽象语法树（AST）。接下来，它对这些令牌做一些变换，然后再将它们转换回 HTML。因此，当字节在被处理的同时，它能够在已有的 HTML 文档基础上进行修改、提取或增添。对比来看，一个标准的 HTML 树解析器则需要将整个文档取回后才能生成一个完整的 DOM 树。基于树的重写器既需要更长的时间才能送达第一个被处理好的字节，也会显著地占用更多的内存。

![img](https://blog-cloudflare-com-assets.storage.googleapis.com/2019/11/image8.png)

<div style="text-align:center">HTML 重写器</div>

举例来说，假设你现在拥有一个存有很多早期内容的大型站点，你现在想将站点服务协议改为 HTTPS。很快你就会遇到由采用 HTTP 协议的资源（图片、脚本、视频）所带来的问题。这些“混合的内容”会带来安全漏洞，同时浏览器会警告或阻止加载这部分资源。更新站点每一个页面上的每一条链接可能会比较困难甚至是不可能的。如果有流式 HTML 重写器的帮助，你可以选择任意一个 HTML 标签上的 URI 属性并将它们由 HTTP 链接更换为 HTTPS。这正是我们在 2016 年所开发的**自动化 HTTPS 重写**特性，目的就是为我们的客户解决混合内容问题。

也许读者心中早已有疑问：“这难道不是一个已解决的问题吗？难道不是有很多广泛使用的开源浏览器都具有能够实现上述目的的 HTML 解析器吗？”。现实是，要写出能满足严格的低延时需求的代码，并运行在全球范围内的 190 多个网络连接点上，任何细小的问题都会变成复杂的工程挑战。

接下来的博文会详细叙述我们如何从在 HTML 页面寻找电子邮箱地址这样一个简单的想法出发，走到开发出一款几乎标准兼容的 HTML 解析器，再到开发出一个 CSS 选择器匹配虚拟机的整个旅程。我希望你能像我们一样，也对其中一些内容感到有趣。

## 在边缘服务器上重写

当通过 Cloudflare 进行内容重写时，我们不希望影响到站点的性能。设计流式 HTML 重写器的平衡在于，通过储存尽可能少的信息来减少响应字节流的中断，同时保持其对匹配到的令牌进行重写的能力。

它和那些用在浏览器中的 HTML 解析器的需求差异在于：

### 输出延时

对于浏览器来讲，文档对象模型（DOM）是解析过程的最终产物，但我们的情况是需要对其进行解析、重写再序列化恢复为 HTML。在使用 Cloudflare 反向代理时，边缘服务器上进行的任何内容处理工作都会在服务器和客户端之间产生延时。因此我们希望能减小 HTML 处理所带来的延时影响，这其中包括解析、重写和序列化恢复为 HTML。为了缩短延时，我们希望所有的这几个阶段都能越快越好。

### 解析器吞吐量

我们假定，通常情况下，浏览器几乎不需要去处理体积大于 1Mb 的 HTML 页面，而且平均页面加载时间最快也要大概 3s 左右。因为浏览器会由于运行脚本或加载其他渲染关键资源而被阻塞，因此 HTML 解析并不是页面加载过程的主要瓶颈。我们可以大致估算出 HTML 解析器的吞吐量为 3Mbps 左右。在 Cloudflare 上，每个 CPU 都需要处理上百兆字节的流量，因此我们所需要的解析器的处理速度也需要根据这个数量级增加。

### 内存限制

多数用户肯定已经意识到了，浏览器在占用内存方面是毫不吝啬的。举例来说，当用浏览器打开下面这段简单的 HTML 标记文本时，它会消耗你很一大块系统内存，直到最终让浏览器标签卡死（此时所有的内存都被解析器消耗掉了）：

```html
<script>
   document.write('<');
   while(true) {
      document.write('aaaaaaaaaaaaaaaaaaaaaaaa');
   }
</script>
```

不幸的是，即使采用流式 HTML 重写，我们也不可避免地要缓存一部分输入。考虑下面这两段 HTML 代码：

```html
<div foo="bar" qux="qux">
```

```
<div foo="bar" qux="qux"
```

当遇到 HTML 页面结尾时，这些看起来很相似的 HTML 片段会被看成完全不一样的东西。第一个片段会被解析成一个开始标签，而第二个片段则会被忽略。但如果仅仅看到一个“<”字符，并且后面跟着一个标签名的话，解析器无法判断它到底是不是一个开始标签。它需要遍历整个输入直到找到结束符号“>”时才能做决定，这所有中间的内容都会被缓存，以便于之后将其作为开始标签令牌传递给下一级。

这个需求迫使浏览器无休止地缓存内容直到最终由于内存耗尽错误而不得不作罢。

就我们所面对的问题而言，消耗上百兆内存来解析一个单独的 HTML 文件对我们来说是无法承受的（实际上限制会更严格——每个请求消耗上万字节都是不可接受的）。从内存使用角度来讲，我们需要采用一个和其他实现相比要精巧得多的方法，并能够在内存空间不足时，优雅地应对所有情况直至完成解析。

## v0：“专用解析器”

正如常见的大型项目一样，一切的起点都是很单纯的。

### 找出并混淆电子邮件地址

